# Verilog HDL 语言快速入门

用手画 CPU 早已是过去的事情了。为了制作超大规模的集成电路，人们开发了一系列的硬件描述语言，以计算机辅助人们生成需要的 HDL 电路。Verilog HDL 便是其中之一，它早已流行于各个芯片大厂中，成为信息技术在硬件方面的得力助手。如果想了解现代计算机的运作原理，除了需要大量的理论知识外，还需要的便是能看懂以这种语言描绘的电路。

阅读本文，您需要一定的编程基础。您可以通过学习本索引的姊妹篇[这是 C++ 的世界！](https://langyo-v2.gitbook.io/cppworld/)来快速入门，然后再回到本篇文章继续学习，会轻松很多。

本文实际上是一则笔记，不能完整地教授您有关 Verilog HDL 的全部语法知识，仅仅能起到快速入门、能基本看懂他人以 Verilog HDL 写成的芯片电路逻辑的作用。

### 目录

* [基本概念](part16#ji-ben-gai-nian)
* [模块](part16#mo-kuai)
* [模块实例化](part16#mo-kuai-shi-li-hua)
* [常数值与常量](part16#chang-shu-zhi-yu-chang-liang)
* [变量](part16#bian-liang)
* [标识符](part16#biao-shi-fu)
* [注释](part16#zhu-shi)
* [赋值](part16#fu-zhi)
* [默认网络类型](part16#mo-ren-wang-luo-lei-xing)
* [运算符](part16#yun-suan-fu)
* [条件判断](part16#tiao-jian-pan-duan)
* [always过程块](part16#always-guo-cheng-kuai)
* [分支选择](part16#fen-zhi-xuan-ze)
* [预处理](part16#yu-chu-li)
* [正逻辑与负逻辑](part16#zheng-luo-ji-yu-fu-luo-ji)
* [电路仿真](part16#dian-lu-fang-zhen)
* [模拟时钟](part16#mo-ni-shi-zhong)
* [系统任务](part16#xi-tong-ren-wu)
* [IcarusVerilog仿真程序的使用](part16#IcrausVerilog-fang-zhen-cheng-xu-de-shi-yong)

## 基本概念

Verilog HDL 是一种 HDL 语言（Hardware Description Language，硬件描述语言）。使用此类语言可以进行抽象度较高的 RTL（Register Transfer Level，寄存器传输级）电路的设计，是在当代设计 CPU 这类超大规模逻辑电路最好的选择。RTL 是根据寄存器间的信号流动和电路逻辑来记述电路动作的一种设计模型。

逻辑综合，是将 RTL 级别记述的抽象电路转换到门电路级别的电路网表的过程。逻辑综合时，针对 ASIC（Application Specific Integrated Circult）、FPGA（Field Programmable Gate Array）等不同的电路实现技术，需要使用这些技术厂商提供的相应的目标元件库。

## 模块

定义一个模块的格式：
```verilog
module <模块名>(
  <输入以及输出的信号定义>,
  ...
);
  <具体的电路描述>
endmodule
```

其中，输入以及输出信号的定义是若干行开头为 input、output 或 inout 的声明，和计算机程序设计语言中的形参颇有相似之处。

具体示例：
```verilog
module adder(
  input wire[31:0] in_0,  // 输入 0 号线
  input wire[31:0] in_1,  // 输入 1 号线
  output wire[31:0] out   // 输出线
);  // 别忘了末尾的分号
  assign out = in_0 + in_1;  // 让输出的信号为两个输入信号的和，加法器的电路会由电路仿真器自动生成
endmodule
```

## 模块实例化

模块实例化，实质上就是建立一个新的模块本体，并指定这个新模块与哪些线路连接。

实例化一个模块的格式：
```verilog
<模块类型名> <模块实例名>(
  .<模块定义的接口名> (<要连入这个接口的线路/寄存器名>),
  ...
);
```

具体示例：
```verilog
// 沿用之前写好的 adder，我们可以将其连接到一些线上
adder adder1(
  .in_0 (register_in_1),
  .in_1 (register_in_2),
  .out (register_out_6)
);
```

## 常数值与常量

这个语言没有定义诸如 true、false、nil、null 这类关键字，而是直接用数字表达逻辑值，简单又直接。数字 0 和 1 分别代表低电平与高电平，也分别代表逻辑假和逻辑真。一定要记住这两个数字在硬件设计语言中的逻辑意义，因为它们与我们日常使用的绝大部分计算机编程语言的含义是正好相反的！

为了表达电路中的特殊状态信号，此语言还定义了两个字母 x 和 z 作为特殊关键字，分别有不定值与高阻值（电气绝缘状态）的意义。

对于具有位宽的信号线与寄存器，可以为其赋予不同进制的常数，可以使用二进制、八进制、十进制与十六进制。一个常数的格式：

```<位宽> '<底数(进制)> <数值>```

这三个部分之间不留空格，互相紧挨着写。位宽必须为一个十进制数，而底数则为一个字母：h 为十六进制，d 为十进制，o 为八进制，b 则为二进制。

具体示例：

> 6'b111100
>
> 6'o74
>
> 6'd60
>
> 6'h3c

另外，这个语言也能定义常量。强烈建议不要往程序中使用魔数（Magic Number，即直接写意义不明的数字），因为那样会让电路描述变得晦涩难懂、难以维护。常量本质上也是常数值数字，但它以一个有意义的名字代替了这个数字，从而提升电路描述的可读性，并且也易于维护。

它的定义格式如下：

````define XXX XXX```

前一个为这个常量的名字，后一个为你要定义的值，可以为任意的常数值。

定义完成后，就可以使用了：

````XXX```

直接将这种格式的文本写进表达式就可以了。

例如：

```verilog
`define A 1
reg n = `A;
```

## 变量

变量的声明格式：

```<数据类型> [符号] [位宽] <变量名> [元素数];```

------

数据类型分为两大类：寄存器型与网络型。当出现了一个寄存器型的变量时，电路生成器会往电路里塞个寄存器单元。而网络型，其实就是线路，这种类型的变量只能起到连接寄存器及 I/O 单元的用途，自身无法储存任何信号。

寄存器型有以下几种：

| 类型 | 默认位宽 | 默认是否有符号 | 类型说明 |
| :--  | :--   | :-- | :-- |
| reg  | 1  | 无 | 比特数据 |
| integer | 32 | 有 | 整数 |
| real | 64 | 有 | 实数 |

网络型有以下几种：

| 类型 | 类型说明 |
| :--  | :--   |
| wire/tri | 线连接 |
| wor/trior | 线或连接 |
| wand/triand | 线与连接 |
| tri1/tri0 | 有上拉或下拉的连接 |
| supply0/supply1 | 接地或接电源的连接 |

> 网络型变量的位宽均默认为 1，并且均无符号。

------

符号分为 signed 与 unsigned，分别是有符号和无符号。符号可以省略。

要将一个变量在有符号与无符号间转换，可以使用系统任务（system task）$signed() 与 $unsigned()。

------

位宽类似于区间，格式如下：

```[a:b]``` 或 ```[a]```

其中，a > b 且 a, b ∈ N（a 和 b 都是正整数或 0）。

原则上，b 应当从 0 数起。例如，我要表达 32 位位宽的线路，在声明变量时应当这么写：

```[31:0]```

而要将其分为 4 份 8 位的位宽，则可以这么写：

```[31:24] [23:16] [15:8] [7:0]```

请注意，位数是由 0 而不是由 1 算起的！

------

元素数的表达格式与位宽一直，但它用于指示此变量是一个阵列（可理解为数组），并由此确定了这个阵列的元素个数。

> P.S. 为什么元素数也用类似区间的格式呢？似乎是为了选定此变量阵列中特定范围的元素？

------

如果要声明多个类型一致的变量，可以将所有要声明的变量名同写在一条声明的变量名的位置，相互间以逗号隔开。

例如：

```reg a, b, c;```

## 标识符

标识符是为变量、模块等取名时使用的名字。它是一连串的字符，而不是单个字符。

标识符仅可由大小写字母(a-z, A-Z)、数字(0-9)、下划线(_)与美元符号($)组成。

## 注释

单行注释：

```// ...```

多行（块状）注释：

```verilog
/*
  ...
 */
```

